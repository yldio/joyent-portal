scalar Date
scalar Object

type Portal {
  id: ID!
  user: User!
  datacenter: Datacenter!
  deploymentGroups(name: String, slug: String): [DeploymentGroup]
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  login: String!
}

type DeploymentGroup {
  id: ID!
  name: String!
  slug:  String!
  services(name: String, slug: String, parentId: ID): [Service]
  version: Version
  history: [Version]
}

type ServiceScale {
  id: ID!
  serviceName: String!
  replicas: Int!
}

enum ConvergenceActionType {
  NOOP
  CREATE
  RECREATE
  START
}

type ConvergenceAction {
  id: ID!
  type: ConvergenceActionType!
  service: String! # service name
  machines: [String]! # instance machine ids
}

type StateConvergencePlan {
  id: ID!
  running: Boolean!
  actions(type: ConvergenceActionType, service: String): [ConvergenceAction]!
}

type Version {
  created: Date! # Either Int or define scalar
  manifestId: ID!
  scale(serviceName: String): [ServiceScale]!
  plan(running: Boolean): StateConvergencePlan
}

enum ManifestType {
  COMPOSE
  MARIPOSA
}

enum ManifestFormat {
  JSON
  YAML
}

type Manifest {
  id: ID!
  created: Float
  type: ManifestType!
  format: ManifestFormat!
  raw: String!
  obj: Object
}

# immutable
type Service {
  id: ID! # unique id for db row
  hash: String! # unique id for version of service
  name: String! # human readable name
  slug:  String!
  instances(name: String, machineId: ID, status: InstanceStatus): [Instance]!
  # metrics: [MetricType]
  currentMetrics: [CurrentMetric]
  connections: [String!] # list of serviceIds
  parent: ID # parent service id
  package: Package! # we don't have this in current mock data,
  environment: [Environment]
  active: Boolean! # let's say that we update the manifest, and remove a service. we still want to track this service even though it might not exist because it might have machines running still
}

# for metrics max / min (I guess)
type Package {
  id: ID!
  name: String!
  type: String!
  memory: Float!
  disk: Float!
  swap: Float!
  lwps: Int!
  vcpus: Int!
  version: String!
  group: String!
}

# environment variables
type Environment {
  name: String!
  value: String!
}

enum InstanceStatus {
  CREATED
  RESTARTING
  RUNNING
  PAUSED
  EXITED
  DELETED
  STOPPED
}

type Instance {
  id: ID!
  name: String!
  machineId: ID!
  status: InstanceStatus!
  # metrics: [InstanceMetric]!
}

type Datacenter {
  id: ID!
  url: String!
  name: String!
  region: String!
}

type InstanceMetric {
  type: MetricType!
  data: [MetricData]!
}

type CurrentMetric {
  name: String!
  value: Float!
  measurement: String!
}

type MetricType {
  id: ID!
  name: String!
  id: ID!
}

type MetricData {
  timestamp: Int!
  value: Float!
}

# we probably wont use some of these queries or arguments
# but this way we expose the entire db through gql
type Query {
  portal: Portal
  user: User
  deploymentGroups(name: String, slug: String): [DeploymentGroup]
  deploymentGroup(id: ID, name: String, slug: String): DeploymentGroup
  serviceScales(serviceName: String, versionId: ID): [ServiceScale]
  serviceScale(id: ID!): ServiceScale
  convergenceActions(type: ConvergenceActionType, service: String, versionId: ID): [ConvergenceAction]
  convergenceAction(id: ID!): ConvergenceAction
  stateConvergencePlans(running: Boolean, versionId: ID): [StateConvergencePlan]
  stateConvergencePlan(id: ID!): StateConvergencePlan
  versions(manifestId: ID, deploymentGroupId: ID): [Version]
  version(id: ID, manifestId: ID): Version
  manifests(type: String, deploymentGroupId: ID): [Manifest]
  manifest(id: ID!): Manifest
  services(name: String, slug: String, parentId: ID, deploymentGroupId: ID, deploymentGroupSlug: String): [Service]
  service(id: ID, hash: ID): Service
  packages(name: String, type: String, memory: Int, disk: Int, swap: Int, lwps: Int, vcpus: Int, version: String, group: String): [Package]
  package(id: ID!): Package
  instances(name: String!, machineId: ID, status: InstanceStatus, serviceId: ID, serviceSlug: String, deploymentGroupId: ID, deploymentGroupSlug: String): [Instance]
  instance(id: ID!): Instance
  datacenter(id: ID, region: String): Datacenter
  datacenters: [Datacenter]
}

type Mutation {
  createDeploymentGroup(name: String!) : DeploymentGroup
  updateDeploymentGroup(id: ID!, name: String!) : DeploymentGroup

  provisionManifest(deploymentGroupId: ID!, type: ManifestType!, format: ManifestFormat!, raw: String!) : Version
  scale(serviceId: ID!, replicas: Int!) : Version

  stopServices(ids: [ID]!) : [Service]
  startServices(ids: [ID]!) : [Service]
  restartServices(ids: [ID]!) : [Service]
  deleteServices(ids: [ID]!) : [Service]

  stopInstances(ids: [ID]!) : [Instance]
  startInstances(ids: [ID]!) : [Instance]
  restartInstances(ids: [ID]!) : [Instance]

  # reprovision() ???
}
